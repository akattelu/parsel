<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>ldoc</h1>



<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
<li><a href="#Tables">Tables</a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>parsel</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>parsel</code></h1>
<p>a parser combinator library for Lua</p>
<p></p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#Parsel.parse">Parsel.parse (input, parser)</a></td>
	<td class="summary">Entry point to parsing a string</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.literal">Parsel.literal (lit)</a></td>
	<td class="summary">Parse any string literal</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.either">Parsel.either (p1, p2)</a></td>
	<td class="summary">Try first parser, and if that fails, try the second parser</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.letter">Parsel.letter ()</a></td>
	<td class="summary">Parse any alphabetic letter</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.digit">Parsel.digit ()</a></td>
	<td class="summary">Parse any digit</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.oneOrMore">Parsel.oneOrMore (p)</a></td>
	<td class="summary">Parse a combinator at least one time and until the parse fails</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.map">Parsel.map (base, mapFn)</a></td>
	<td class="summary">Map the result of a parser</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.any">Parsel.any (...)</a></td>
	<td class="summary">Parse any combinators specified in the list</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.seq">Parsel.seq (...)</a></td>
	<td class="summary">Parse all combinators in sequence</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.zeroOrMore">Parsel.zeroOrMore (p)</a></td>
	<td class="summary">Parse zero or more instances of combinators</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.optional">Parsel.optional (p)</a></td>
	<td class="summary">Optionally parse a combinator, return Parsel.nullResult if not matched</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.char">Parsel.char ()</a></td>
	<td class="summary">Match any single character</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.charExcept">Parsel.charExcept (char)</a></td>
	<td class="summary">Match anything but the specified literal single character</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.newline">Parsel.newline ()</a></td>
	<td class="summary">Match single newline char</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.whitespace">Parsel.whitespace ()</a></td>
	<td class="summary">Match whitespace
 Matches at least one tab, space, or newline and consumes it</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.optionalWhitespace">Parsel.optionalWhitespace ()</a></td>
	<td class="summary">Match optional whitespace
 Optionally matches and consumes spaces, tabs and newlines</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.lazy">Parsel.lazy (f)</a></td>
	<td class="summary">Returns a parser that lazily evaluates a function</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.anyLiteral">Parsel.anyLiteral (...)</a></td>
	<td class="summary">Match any literal passed in, succeeds with the match</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.sepBy">Parsel.sepBy (p, delim)</a></td>
	<td class="summary">Match parsers delimited by successful parse of delim
 the result is a table containing just the parsed values (delimiter ignored)
 fails if parsing a delimiter then parser fails, or if the first parsing of p fails</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.exclude">Parsel.exclude (p, exclusionFunc)</a></td>
	<td class="summary">Fails a parser if it matches condition set by exclusionFunc</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#Parsel.untilLiteral">Parsel.untilLiteral (literal)</a></td>
	<td class="summary">Match the parsers string until the specified literal is found</td>
	</tr>
</table>
<h2><a href="#Tables">Tables</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#Parsel.nullResult">Parsel.nullResult</a></td>
	<td class="summary">a result indicating an optional match
 returned as a placeholder when an optional match did not succeed</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "Parsel.parse"></a>
    <strong>Parsel.parse (input, parser)</strong>
    </dt>
    <dd>
    Entry point to parsing a string


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">input</span>
         the string to match
        </li>
        <li><span class="parameter">parser</span>
         to use on the string
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        the result returned by the parser
    </ol>




</dd>
    <dt>
    <a name = "Parsel.literal"></a>
    <strong>Parsel.literal (lit)</strong>
    </dt>
    <dd>
    Parse any string literal


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">lit</span>
         the literal to match
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function matching the literal
    </ol>




</dd>
    <dt>
    <a name = "Parsel.either"></a>
    <strong>Parsel.either (p1, p2)</strong>
    </dt>
    <dd>
    Try first parser, and if that fails, try the second parser


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">p1</span>
         the first parser to try
        </li>
        <li><span class="parameter">p2</span>
         the second parser to try
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.letter"></a>
    <strong>Parsel.letter ()</strong>
    </dt>
    <dd>
    Parse any alphabetic letter



    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.digit"></a>
    <strong>Parsel.digit ()</strong>
    </dt>
    <dd>
    Parse any digit



    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.oneOrMore"></a>
    <strong>Parsel.oneOrMore (p)</strong>
    </dt>
    <dd>
    Parse a combinator at least one time and until the parse fails


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">p</span>
         the parser to attempt one or more times
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.map"></a>
    <strong>Parsel.map (base, mapFn)</strong>
    </dt>
    <dd>
    Map the result of a parser


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">base</span>
         parser to run and map the result of
        </li>
        <li><span class="parameter">mapFn</span>
         function to apply to the result of the parser operation
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a new parser function with a mapped result
    </ol>




</dd>
    <dt>
    <a name = "Parsel.any"></a>
    <strong>Parsel.any (...)</strong>
    </dt>
    <dd>
    Parse any combinators specified in the list


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         a list of required parsers to parse in attempt in order
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a combined parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.seq"></a>
    <strong>Parsel.seq (...)</strong>
    </dt>
    <dd>
    Parse all combinators in sequence


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         a list of required parsers to parse in sequence
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a combined parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.zeroOrMore"></a>
    <strong>Parsel.zeroOrMore (p)</strong>
    </dt>
    <dd>
    Parse zero or more instances of combinators


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">p</span>
         the parser to attempt zero or more times
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.optional"></a>
    <strong>Parsel.optional (p)</strong>
    </dt>
    <dd>
    Optionally parse a combinator, return Parsel.nullResult if not matched


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">p</span>
         parser to attempt, if failed, nullResult will be returned
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="index.html#Parsel.nullResult">Parsel.nullResult</a>
    </ul>


</dd>
    <dt>
    <a name = "Parsel.char"></a>
    <strong>Parsel.char ()</strong>
    </dt>
    <dd>
    Match any single character



    <h3>Returns:</h3>
    <ol>

        a parser function that matches any character
    </ol>




</dd>
    <dt>
    <a name = "Parsel.charExcept"></a>
    <strong>Parsel.charExcept (char)</strong>
    </dt>
    <dd>
    Match anything but the specified literal single character


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">char</span>
         character to exclude
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function that matches any character besides char
    </ol>




</dd>
    <dt>
    <a name = "Parsel.newline"></a>
    <strong>Parsel.newline ()</strong>
    </dt>
    <dd>
    Match single newline char



    <h3>Returns:</h3>
    <ol>

        a parser function that matches a newline character
    </ol>




</dd>
    <dt>
    <a name = "Parsel.whitespace"></a>
    <strong>Parsel.whitespace ()</strong>
    </dt>
    <dd>
    Match whitespace
 Matches at least one tab, space, or newline and consumes it



    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.optionalWhitespace"></a>
    <strong>Parsel.optionalWhitespace ()</strong>
    </dt>
    <dd>
    Match optional whitespace
 Optionally matches and consumes spaces, tabs and newlines



    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.lazy"></a>
    <strong>Parsel.lazy (f)</strong>
    </dt>
    <dd>
    Returns a parser that lazily evaluates a function


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">f</span>
         func (must return a parser)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.anyLiteral"></a>
    <strong>Parsel.anyLiteral (...)</strong>
    </dt>
    <dd>
    Match any literal passed in, succeeds with the match


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">...</span>
         a sequence of literals to try in order
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function that matches any of the literals
    </ol>




</dd>
    <dt>
    <a name = "Parsel.sepBy"></a>
    <strong>Parsel.sepBy (p, delim)</strong>
    </dt>
    <dd>
    Match parsers delimited by successful parse of delim
 the result is a table containing just the parsed values (delimiter ignored)
 fails if parsing a delimiter then parser fails, or if the first parsing of p fails


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">p</span>
         the parser to match repeatedly
        </li>
        <li><span class="parameter">delim</span>
         the parser to match as a delimiter
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function
    </ol>




</dd>
    <dt>
    <a name = "Parsel.exclude"></a>
    <strong>Parsel.exclude (p, exclusionFunc)</strong>
    </dt>
    <dd>
    Fails a parser if it matches condition set by exclusionFunc


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">p</span>
         parser to wrap
        </li>
        <li><span class="parameter">exclusionFunc</span>
         if this function returns true, the parser will fail
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function that parses p and fails if the exclusionFunc criteria is matched
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">local</span> ignoreOdd = parsel.<span class="function-name">exclude</span>(parsel.<span class="function-name">digit</span>(), <span class="keyword">function</span>(d)
  <span class="keyword">return</span> <span class="global">tonumber</span>(d)%<span class="number">2</span> == <span class="number">1</span>
<span class="keyword">end</span>)
<span class="keyword">local</span> evenString = parsel.<span class="function-name">oneOrMore</span>(ignoreOdd)
<span class="global">table</span>.<span class="function-name">concat</span>(parsel.<span class="function-name">parse</span>(<span class="string">"2468"</span>).result, <span class="string">""</span>)
 <span class="comment">-- 246</span></pre>
    </ul>

</dd>
    <dt>
    <a name = "Parsel.untilLiteral"></a>
    <strong>Parsel.untilLiteral (literal)</strong>
    </dt>
    <dd>
    Match the parsers string until the specified literal is found


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">literal</span>
         the literal to match until
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        a parser function matched until right before the literal is found or end of string
    </ol>



    <h3>Usage:</h3>
    <ul>
        <pre class="example"><span class="keyword">local</span> untilEnd = parsel.<span class="function-name">untilLiteral</span>(<span class="string">'end'</span>)
parsel.<span class="function-name">parse</span>(<span class="string">"if then end"</span>).result
 <span class="comment">-- "if then "</span></pre>
    </ul>

</dd>
</dl>
    <h2 class="section-header "><a name="Tables"></a>Tables</h2>

    <dl class="function">
    <dt>
    <a name = "Parsel.nullResult"></a>
    <strong>Parsel.nullResult</strong>
    </dt>
    <dd>
    a result indicating an optional match
 returned as a placeholder when an optional match did not succeed


    <h3>Fields:</h3>
    <ul>
        <li><span class="parameter">type</span>

        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="index.html#Parsel.optional">Parsel.optional</a>
    </ul>


</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/lunarmodules/LDoc">LDoc 1.5.0</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
